diff --git a/arch/x86/entry/syscalls/syscall_64.tbl b/arch/x86/entry/syscalls/syscall_64.tbl
index c29976eca4a8..6a4d50bcf8fc 100644
--- a/arch/x86/entry/syscalls/syscall_64.tbl
+++ b/arch/x86/entry/syscalls/syscall_64.tbl
@@ -358,6 +358,9 @@
 434	common	pidfd_open		__x64_sys_pidfd_open
 435	common	clone3			__x64_sys_clone3/ptregs
 
+#ihhwang
+436 common plmt_set_comm    __x64_sys_plmt_set_comm
+
 #
 # x32-specific system call numbers start at 512 to avoid cache impact
 # for native 64-bit operation. The __x32_compat_sys stubs are created
diff --git a/fs/exec.c b/fs/exec.c
index d62cd1d71098..ec8b7d74d765 100644
--- a/fs/exec.c
+++ b/fs/exec.c
@@ -78,6 +78,9 @@ int suid_dumpable = 0;
 static LIST_HEAD(formats);
 static DEFINE_RWLOCK(binfmt_lock);
 
+//ihhwang
+extern int is_plmt_process(const char *process_name);
+
 void __register_binfmt(struct linux_binfmt * fmt, int insert)
 {
 	BUG_ON(!fmt);
@@ -1377,6 +1380,13 @@ void setup_new_exec(struct linux_binprm * bprm)
 	perf_event_exec();
 	__set_task_comm(current, kbasename(bprm->filename), true);
 
+	/* ihhwang */
+	if(is_plmt_process(current->comm)){
+		printk("this is plmt_process : %s\n", current->comm);
+		current->mm->plmt_enable = 1;
+	}
+	//
+
 	/* Set the new mm task size. We have to do that late because it may
 	 * depend on TIF_32BIT which is only updated in flush_thread() on
 	 * some architectures like powerpc
diff --git a/include/linux/mm_types.h b/include/linux/mm_types.h
index 270aa8fd2800..f6bd5bfbdd2f 100644
--- a/include/linux/mm_types.h
+++ b/include/linux/mm_types.h
@@ -526,11 +526,21 @@ struct mm_struct {
 		struct work_struct async_put_work;
 	} __randomize_layout;
 
+	//ihhwang
+	//unsigned long this_page_fault_address;
+	unsigned long prev_page_fault_address;
+	pte_t prev_page_fault_pte;
+	unsigned int plmt_enable;
+	unsigned long page_fault_cnt; 
+	//
+	
 	/*
 	 * The mm_cpumask needs to be at the end of mm_struct, because it
 	 * is dynamically sized based on nr_cpu_ids.
 	 */
 	unsigned long cpu_bitmap[];
+
+
 };
 
 extern struct mm_struct init_mm;
diff --git a/include/linux/plmt.h b/include/linux/plmt.h
new file mode 100644
index 000000000000..9836cacfacad
--- /dev/null
+++ b/include/linux/plmt.h
@@ -0,0 +1,11 @@
+#ifndef _LINUX_PLMT_H
+#define _LINUX_PLMT_H
+
+#define MAX_NAME_LEN 32
+
+char plmt_process_name[MAX_NAME_LEN];
+
+long plmt_set_comm(const char __user *process_name);
+int is_plmt_process(const char * process_name);
+
+#endif
\ No newline at end of file
diff --git a/include/linux/syscalls.h b/include/linux/syscalls.h
index f7c561c4dcdd..352355bd6f47 100644
--- a/include/linux/syscalls.h
+++ b/include/linux/syscalls.h
@@ -1215,6 +1215,8 @@ asmlinkage long sys_mmap_pgoff(unsigned long addr, unsigned long len,
 			unsigned long fd, unsigned long pgoff);
 asmlinkage long sys_old_mmap(struct mmap_arg_struct __user *arg);
 
+// ihhwang
+asmlinkage long sys_plmt_set_comm(const char __user * process_name);
 
 /*
  * Not a real system call, but a placeholder for syscalls which are
diff --git a/kernel/Makefile b/kernel/Makefile
index daad787fb795..ee7ebc9fc41b 100644
--- a/kernel/Makefile
+++ b/kernel/Makefile
@@ -10,7 +10,8 @@ obj-y     = fork.o exec_domain.o panic.o \
 	    extable.o params.o \
 	    kthread.o sys_ni.o nsproxy.o \
 	    notifier.o ksysfs.o cred.o reboot.o \
-	    async.o range.o smpboot.o ucount.o
+	    async.o range.o smpboot.o ucount.o \
+	    plmt.o
 
 obj-$(CONFIG_MODULES) += kmod.o
 obj-$(CONFIG_MULTIUSER) += groups.o
diff --git a/kernel/plmt.c b/kernel/plmt.c
new file mode 100644
index 000000000000..7cdd621e0314
--- /dev/null
+++ b/kernel/plmt.c
@@ -0,0 +1,24 @@
+#include <linux/syscalls.h>
+#include <linux/plmt.h>
+
+
+
+//system call to enable plmt
+SYSCALL_DEFINE1(plmt_set_comm, const char __user *, process_name){
+
+    long ret;
+    printk("set plmt process name : %s\n", process_name);
+    ret = strncpy_from_user(plmt_process_name, process_name, MAX_NAME_LEN-1);
+
+    return ret;
+}
+
+// check this is plmt process 
+int is_plmt_process(const char * process_name){
+    
+    if(!strncmp(process_name, plmt_process_name, MAX_NAME_LEN))
+        return 1;
+
+    return 0;
+    
+}
\ No newline at end of file
diff --git a/mm/memory.c b/mm/memory.c
index cb7c940cf800..6dd130aaf2f7 100644
--- a/mm/memory.c
+++ b/mm/memory.c
@@ -3821,6 +3821,29 @@ static vm_fault_t wp_huge_pud(struct vm_fault *vmf, pud_t orig_pud)
 static vm_fault_t handle_pte_fault(struct vm_fault *vmf)
 {
 	pte_t entry;
+	// ihhwang
+	//pte_t = pte_clear_flag(pte_t pte, _PAGE_PRESENT)
+	
+	if(current && current->mm && current->mm->plmt_enable){
+		char mode;
+		char type;
+
+		if(vmf->flags & FAULT_FLAG_WRITE)
+			mode = 'w';
+		else
+			mode = 'r';
+
+		if(vmf->flags & FAULT_FLAG_INSTRUCTION)
+			type = 'i';
+		else 
+			type = 'd';
+
+		printk("prev page address : %lx", vmf->vma->vm_mm->prev_page_fault_address & PAGE_MASK);
+		printk("%lu : this page address : %lx, mode : %c, type : %c",++(vmf->vma->vm_mm->page_fault_cnt), 
+			vmf->address & PAGE_MASK, mode, type);
+		vmf->vma->vm_mm->prev_page_fault_address = vmf->address;	
+	}
+	//
 
 	if (unlikely(pmd_none(*vmf->pmd))) {
 		/*
@@ -3998,6 +4021,12 @@ static vm_fault_t __handle_mm_fault(struct vm_area_struct *vma,
 vm_fault_t handle_mm_fault(struct vm_area_struct *vma, unsigned long address,
 		unsigned int flags)
 {
+	/*
+	if(current->mm->plmt_enable){
+		printk("comm : %s\n", current->comm);
+		printk("handle mm fault start. address : %lu\n", address);
+	}
+	*/
 	vm_fault_t ret;
 
 	__set_current_state(TASK_RUNNING);
